import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# Load the data
cnc_data = pd.read_csv('C:/Users/hp/Videos/Book2.csv')
cnc_data['Timestamp'] = pd.to_datetime(cnc_data['Timestamp'])
cnc_data.set_index('Timestamp', inplace=True)


# Dropping rows with NaN values generated by rolling, shifting, etc.

cnc_data.dropna(inplace=True)




data = cnc_data[['SpindleSpeed']]
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data)

# Function to create dataset
def create_dataset(dataset, time_step=1):
    dataX, dataY = [], []
    for i in range(len(dataset) - time_step - 1):
        a = dataset[i:(i + time_step), 0]
        dataX.append(a)
        dataY.append(dataset[i + time_step, 0])
    return np.array(dataX), np.array(dataY)

time_step = 500 # Adjust this based on the problem
X, y = create_dataset(scaled_data, time_step)
print("Shape of X before reshaping:", X.shape)

print("Shape of y before reshaping:", y.shape)

# Reshape X to be [samples, time steps, features]
X = X.reshape(X.shape[0], X.shape[1], 1)
print("Shape of X after reshaping:", X.shape)
print("Shape of Y after reshaping:", y.shape)

# Split the data into train and test sets
train_size = int(len(X) * 0.8)
test_size = len(X) - train_size
X_train, X_test = X[0:train_size], X[train_size:len(X)]
y_train, y_test = y[0:train_size], y[train_size:len(y)]

# Check shapes of training and test sets
print("Shape of X_train:", X_train.shape)
print("Shape of y_train:", y_train.shape)
print("Shape of X_test:", X_test.shape)
print("Shape of y_test:", y_test.shape)

# Create the LSTM model
model = Sequential()
model.add(LSTM(200, return_sequences=True, input_shape=(time_step, 1)))
model.add(LSTM(100, return_sequences=True))
model.add(LSTM(100, return_sequences=True))
model.add(LSTM(50, return_sequences=True))
model.add(LSTM(50, return_sequences=False))
model.add(Dense(50))
model.add(Dense(50))
model.add(Dense(25))
model.add(Dense(1))

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, batch_size=2, epochs=35, verbose=1)
# Make predictions
train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

# Inverse transform to get actual values
train_predict = scaler.inverse_transform(train_predict)
test_predict = scaler.inverse_transform(test_predict)

# Inverse transform y_train and y_test
y_train_inv = scaler.inverse_transform([y_train])
y_test_inv = scaler.inverse_transform([y_test])

# Flatten the arrays for RMSE calculation
y_train_inv = y_train_inv.flatten()
y_test_inv = y_test_inv.flatten()

# Calculate RMSE
train_rmse = np.sqrt(np.mean((train_predict.flatten() - y_train_inv) ** 2))
test_rmse = np.sqrt(np.mean((test_predict.flatten() - y_test_inv) ** 2))

print(f"Train RMSE: {train_rmse}")
print(f"Test RMSE: {test_rmse}")

# Prepare data for plotting
train_index = cnc_data.index[time_step:train_size+time_step]
test_index = cnc_data.index[train_size+time_step+1:len(scaled_data)+1]

# Plotting the results
plt.figure(figsize=(14, 8))
plt.plot(cnc_data.index, scaler.inverse_transform(scaled_data), label='Actual Data')
plt.plot(train_index, train_predict, label='Train Predict')
plt.plot(test_index, test_predict, label='Test Predict')
plt.xlabel('Date')
plt.ylabel('Spindle Speed')
plt.title('Spindle Speed Prediction')
plt.legend()
plt.grid(True)
plt.savefig('spindle_speed_prediction.png')
plt.show()

# Save the model performance metrics
with open('model_performance.txt', 'w') as file:
    file.write(f'Train RMSE: {train_rmse}\n')
    file.write(f'Test RMSE: {test_rmse}\n')

print("Prediction report generated successfully.")

print(scaled_data)
future_predictions = []
future_dates=[]
last_date =(cnc_data.index[-1])
print("last date is: ")
print(last_date)
future_steps = 100
current_step = scaled_data[-time_step:].copy()
print("current_step is: ")
print(current_step)
for i in range(future_steps):
    X_input = np.reshape(current_step, (1, time_step, 1))
    next_value = model.predict(X_input)
    future_predictions.append(next_value[0, 0])
    current_step = np.append(current_step[1:], next_value)
i=0
# Update the current step with the new prediction
while len(future_dates) < future_steps:
    next_date = last_date + pd.DateOffset(days=(i + 1))
    if next_date.weekday() < 5:  # Monday to Friday are 0 to 4
        future_dates.append(next_date)
       # Append only the date part
    i += 1

future_predictions = scaler.inverse_transform(np.array(future_predictions).reshape(-1, 1)).flatten()
print("future prediction")
print(future_predictions)

    # Assign predicted value to the last position

# Set how many future time steps you want to predict

print("future prdiction")
# Prepare future dates for plotting
print(future_predictions.shape)
print("future date")
print(future_dates)



df_future_predictions = pd.DataFrame({
    'Date': future_dates,
    'Prediction': future_predictions
})

# Plotting the results including future predictions

# Plotting the results including future predictions
plt.figure(figsize=(14, 8))

# Plot actual data
plt.plot(cnc_data.index[0:], scaler.inverse_transform(scaled_data[0:]), label='Actual Data')

# Plot training predictions
plt.plot(train_index, train_predict, label='Train Predictions', linestyle='--', color='green')

# Plot test predictions
plt.plot(test_index, test_predict, label='Test Predictions', linestyle='--', color='orange')

# Plot future predictions
plt.plot(df_future_predictions['Date'], df_future_predictions['Prediction'], label='Future Predictions', linestyle='--', color='purple')

# Customize x-axis ticks to show exact dates
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.gca().xaxis.set_major_locator(plt.MaxNLocator(10))  # Set maximum number of ticks for better spacing

plt.xlabel('Timestamp')
plt.ylabel('Spindle Speed')
plt.title('Spindle Speed Prediction using LSTM')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig('spindle_speed_prediction_with_future.png')
plt.show()

# Save future predictions to a CSV file
future_predictions_df = pd.DataFrame(data={'Date': future_dates, 'Future Predictions': future_predictions.flatten()})
future_predictions_df.to_csv('C:/Users/hp/Pictures/future_predictions.csv', index=False)
print("Future predictions saved to future_predictions.csv")
